import argparse
import re

import pandas as pd

#########################################################
################# Extract Judge Answer ##################
#########################################################


def extract_bool_answer(row, judge_answer_column_name):
    """Extract a boolean answer from the judge's reponse."""
    MATCH_PATTERN = "<answer>.*</answer>"

    if judge_answer_column_name not in row:
        raise ValueError(f"Column `{judge_answer_column_name}` not found in row.")

    # Get the last (-1) message, which should be the assistant's response.
    full_answer = row[judge_answer_column_name][-1]
    if ("role" not in full_answer) or (full_answer["role"] != "assistant"):
        raise ValueError("Field `role` not found or does not match the assistant.")

    # Extract the content of the assistant's response.
    if "content" not in full_answer:
        raise ValueError("Field `content` not found in the judge's response.")
    full_answer = full_answer["content"]
    if not full_answer:
        print("(!) Full Answer ERROR:", full_answer)
        return "Error"

    # Find the (single word) answer within the full response.
    answer = re.search(MATCH_PATTERN, full_answer)
    if answer:
        answer = answer.group(0)
        answer = answer.replace("<answer>", "")
        answer = answer.replace("</answer>", "")
    else:
        print("(!) Answer ERROR:", answer)
        return "Error"

    # Extract the boolean answer (Yes or No) from the identified answer.
    if (len(answer) >= 3) and (answer[:3].lower() == "yes"):
        return True
    elif (len(answer) >= 2) and (answer[:2].lower() == "no"):
        return False
    else:
        print("(!) Extraction ERROR:", full_answer)
        return "Error"


#########################################################
###################### Main #############################
#########################################################


DATASET_IN_PATH = "./dataset_with_prompts.csv"
DATASET_OUT_PATH = "./dataset_with_judged_prompts.csv"
JUDGE_ANSWERS_PREFIX = "./judge_inference_"
JUDGE_ANSWERS_FILE_TYPE = "jsonl"


def get_judge_answer_col_name(attribute_name):
    """Get the column name for the judge's answer."""
    return "judge_answer_" + attribute_name


def get_judge_answer_bool_col_name(attribute_name):
    """Get the column name for the judge's extracted bool answer."""
    return "judge_answer_tf_" + attribute_name


def main(args):
    """Main function for polaris judge post-procesing.

    This function merges our dataset (which includes the prompts for the judge) with the
    judge's answers, which where generated by Polaris' `vllm.yaml job`. It is assumed
    the the order of examples has not changed during dataset judgement.
    """
    attribute_names = ["helpful", "honest", "safe", "valid"]

    df_dataset = pd.read_csv(DATASET_IN_PATH)

    for attribute_name in attribute_names:
        judged_prompts_path = (
            f"{JUDGE_ANSWERS_PREFIX}{attribute_name}.{JUDGE_ANSWERS_FILE_TYPE}"
        )
        judged_prompts = pd.read_json(judged_prompts_path, lines=True)
        judged_prompts_list = judged_prompts["messages"].to_list()

        print(f"Prompts for attribute `{attribute_name}`: {len(judged_prompts_list)}")
        assert len(judged_prompts_list) == len(df_dataset)
        ans_col = get_judge_answer_col_name(attribute_name)
        df_dataset[ans_col] = pd.Series(judged_prompts_list)

        ans_bool_col = get_judge_answer_bool_col_name(attribute_name)
        df_dataset[ans_bool_col] = df_dataset.apply(
            extract_bool_answer, args=(ans_col,), axis=1
        )

    df_dataset.to_csv(DATASET_OUT_PATH, index=False)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Judge a dataset.")
    parser.add_argument(
        "--dataset_in_path",
        type=str,
        default=DATASET_IN_PATH,
        help="Path of the input CSV file with dataset, plus the judge prompts.",
    )
    parser.add_argument(
        "--dataset_out_path",
        type=str,
        default=DATASET_OUT_PATH,
        help="Path of the output CSV file, where the judged prompts will be saved.",
    )
    parser.add_argument(
        "--judge_answers_prefix",
        type=str,
        default=JUDGE_ANSWERS_PREFIX,
        help="Prefix of the paths that include the judge's answers (per attribute).",
    )
    args = parser.parse_args()
    main(args)
